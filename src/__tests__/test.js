import fuzzySearch, { normalizeText } from '../index'
import { experimentalSmartFuzzyMatch } from '../impl'

describe('fuzzySearch', () => {
  const matches = (text, query, expectedScore, expectedIndices = null) => {
    // console.log(`${text} ${query}`)
    const results = fuzzySearch([text])(query)
    expect(results.length).toBe(1)
    const [result] = results
    expect(result.item).toBe(text)
    if (expectedScore != null) {
      expect(result.score).toBeCloseTo(expectedScore)
    }
    if (expectedIndices) {
      expect(result.matches.length).toBe(1)
      expect(result.matches[0]).toEqual(expectedIndices)
    }
  }
  it(`can match by: exact match`, () => {
    matches('foo', 'foo', 0, [[0, 2]])
    matches('ABC', 'ABC', 0)
    matches('ƒÖ≈õƒá', 'ƒÖ≈õƒá', 0)
    matches('üìö', 'üìö', 0)
    matches('123¬°‚Ñ¢¬£¬ß', '123¬°‚Ñ¢¬£¬ß', 0)
    matches('≈ºabki', '≈ºabki', 0)
    matches('zƒÖbki', 'zƒÖbki', 0)
    matches('—Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫', '—Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫', 0)
    matches('Ê±âËØ≠', 'Ê±âËØ≠', 0)
    matches('Êó•Êú¨Ë™û', 'Êó•Êú¨Ë™û', 0)
    matches('ÌïúÍµ≠Ïñ¥', 'ÌïúÍµ≠Ïñ¥', 0)
    matches('‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢', '‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢', 0)
    matches(' he ', ' he ', 0)
    matches('¬†he\n\t', '¬†he\n\t', 0) // hard space
  })
  it(`can match by: full match`, () => {
    matches('Foo', 'foo', 0.1)
    matches('FOO', 'foo', 0.1)
    matches('foo', 'Foo', 0.1)
    matches('foo', 'FOO', 0.1)
    matches('foo', 'foo ', 0.1)
    matches(' foo bar', 'foo bar', 0.1)
    // eslint-disable-next-line
    // matches('foo¬†bar', 'foo bar', 0.1) // hard space
    matches('≈ªabki', '≈ºabki', 0.1, [[0, 4]])
    matches('≈ªabki', 'zabki', 0.1)
    matches('ZƒÖbki', 'zabki', 0.1)
    matches('ZABKI', '≈ºƒÖbki', 0.1)
    matches('Szczeg√≥≈Ç', 'szczegol', 0.1)
    matches('–Ø–∑—ã–∫', '—è–∑—ã–∫', 0.1, [[0, 3]])
    // Check for regression - previously highlight would be off by whitespace
    matches('foo ', 'foo', 0.1, [[0, 2]])
  })
  it(`can match by: "Starts with" match`, () => {
    // TODO: startsWith with exact diacritics should match more strongly (e.g. ≈ºa -> ≈ªabka before Zabawa), but case-insensitively
    // (we want `to` to match Tom more than Couto)
    matches('Tomasz Kapelak', 'to', 0.5, [[0, 1]])
    matches('≈ªabka - oferta', '≈ªab', 0.5, [[0, 2]])
    matches('≈ªabka - oferta', 'Zab', 0.5)
    matches('≈ªabka - oferta', 'zab', 0.5)
    matches('Szczeg√≥≈Çowe', 'szcz', 0.5, [[0, 3]])
    matches('–†—É—Å—Å–∫–∏–π —è–∑—ã–∫', '—Ä—É—Å', 0.5, [[0, 2]])
    matches('Ê±âËØ≠', 'Ê±â', 0.5, [[0, 0]])
    matches('Êó•Êú¨Ë™û', 'Êó•', 0.5, [[0, 0]])
    // TODO: Fix Hangul highlighting
    // matches('ÌïúÍµ≠Ïñ¥', 'Ìïú', 0.5, [[0, 0]])
    matches('‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢', '‡∏†', 0.5, [[0, 0]])
    // Check for regression - previously highlight would be 1 longer
    matches('There is no icon', 'the ', 0.5, [[0, 2]])
  })
  it(`can match by: contains query (at word boundary) exactly`, () => {
    matches('[N4] Marketing', 'Market', 0.9, [[5, 10]])
    matches('Wypad do ≈ªabki', '≈ªabk', 0.9)
    matches('—Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫', '—è–∑—ã–∫', 0.9, [[8, 11]])
  })
  it(`can match by: contains query (at word boundary)`, () => {
    matches('[N4] Marketing', 'market', 1, [[5, 10]])
    matches('Wypad do ≈ªabki', 'zabki', 1)
    matches('Myjcie zƒÖbki!!', 'zabki', 1, [[7, 11]])
    matches('–†—É—Å—Å–∫–∏–π –Ø–∑—ã–∫', '—è–∑—ã–∫', 1, [[8, 11]])
  })
  it(`can match by: contains query (at any position)`, () => {
    matches('Marco Couto', 'To', 2, [[9, 10]])
    matches('Ê±âËØ≠', 'ËØ≠', 2, [[1, 1]])
    matches('Êó•Êú¨Ë™û', 'Êú¨', 2, [[1, 1]])
    // TODO: Fix Hangul highlighting
    // matches('ÌïúÍµ≠Ïñ¥', 'Íµ≠', 2, [[1, 1]])
    matches('‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢', '‡∏≤', 2, [[1, 1]])
  })
  it(`can match by words (in some order)`, () => {
    matches('Setting to disable fuzzy search', 'fuzzy setting', 1.9, [
      [0, 6],
      [19, 23],
    ])
    matches('Setting to disable fuzzy search', 'disable setting fuzzy search', 2.3, [
      [0, 6],
      [11, 17],
      [19, 23],
      [25, 30],
    ])
    // matches by words before matching by letters
    matches('Cloak Duck, test clock', 'clock test', 1.9, [
      [12, 15],
      [17, 21],
    ])
  })
  it(`can match by: contains letters awww yisss fuzzzzz`, () => {
    // score(of)
    const s = (score) => 2 + score
    // full word
    const w = 0.2
    // beginning of word
    const b = 0.4
    // middle of word
    const m = 0.8
    // middle of word (1 or 2 chars)
    const ms = 1.6

    // TODO: Matching diacritics should be scored better
    matches('Wypad do ≈ªabki', 'wd≈º', s(b + ms + b), [
      [0, 0],
      [4, 4],
      [9, 9],
    ])
    matches('Wypad do ≈ªabki', 'wdz', s(b + ms + b), [
      [0, 0],
      [4, 4],
      [9, 9],
    ])
    matches('Wypad do ≈ªabki', 'wypa≈ºab', s(b + b), [
      [0, 3],
      [9, 11],
    ])
    matches('Wypad do ≈ªabki', 'wypa ≈ºab', s(b + w + b), [
      [0, 3],
      [5, 5],
      [9, 11],
    ])
    matches('Marco Couto', 'mc', s(b + ms))
    matches('Marco Couto', 'm c', s(b + b))
    matches('Tomasz Kapelak', 'tokp', s(b + b + ms))
    // trying to match `Referral` (and not r, e in Marketing) is probably too complex/magic
    matches('[Marketing ] Referral Program', 'mrefp', s(ms + ms + ms + ms + b))
    matches('[Marketing ] Referral Program', 'm refp', s(ms + w + b + b))
    matches('Nozbe.com web site', 'website')
    matches('KsiƒÖ≈ºka 10 steps EN', '10en', s(w + ms + ms))
    matches('Won‚Äôt fix', 'wontfix')
    matches('[HR] JavaScript Developer', 'jsdev', s(b + ms + b), [
      [5, 5],
      [9, 9],
      [16, 18],
    ])
    matches('MacKay', 'mckay', s(b + m))
    matches('–†—É—Å—Å–∫–∏–π –Ø–∑—ã–∫', '—É—Å–∫–∏', s(ms + ms))
    matches('–†—É—Å—Å–∫–∏–π –Ø–∑—ã–∫', '—Ä—É—è', s(b + b), [
      [0, 1],
      [8, 8],
    ])
    matches('Ê±âËØ≠ÁöÑÔºåÂèàÁß∞Ê±âÊñá„ÄÅËèØÊñá„ÄÅÂîêÊñá', 'Ê±âËØ≠Âîê', s(b + ms), [
      [0, 1],
      [12, 12],
    ])
    matches('Êó•Êú¨Ë™û', 'Êó•Ë™û', s(b + ms), [
      [0, 0],
      [2, 2],
    ])
    matches('ÌïúÍµ≠Ïñ¥', 'ÌïúÏñ¥', s(b + ms))
    // matches('ÌïúÍµ≠Ïñ¥', 'ÌïúÏñ¥', 2, [[0, 0], [2, 2]]) // FIXME: Fix highglighting for Hangul
  })
  const noMatch = (text, query) => {
    const results = fuzzySearch([text])(query)
    expect(results.length).toBe(0)
  }
  it(`can not match everything, okay :(`, () => {
    // no stemming
    noMatch('recognition', 'recognize')
    noMatch('production', 'produce')
    noMatch('≈ºo≈ÇƒÖd≈∫', '≈ºo≈Çƒôdzie')
    noMatch('take', 'took')
    noMatch('produce', 'reproduce')

    // no synonyms/alt spellings
    noMatch('McKay', 'MacKay')
    noMatch('mac', 'macintosh')
    noMatch('grey', 'gray')

    // no soundex
    noMatch('kay', 'kai')

    // no substitutions/typo autofix
    noMatch('leters', 'letters')
    noMatch('letters', 'lettesr')
    noMatch('referral', 'referarl')
  })
  it(`can search by key`, () => {
    expect(
      fuzzySearch([{ t: 'foo' }, { t: 'foo2' }, { t: 'bar' }], { key: 't' })('foo'),
    ).toMatchObject([{ item: { t: 'foo' } }, { item: { t: 'foo2' } }])
  })
  it(`can search by many keys`, () => {
    const u1 = { name: 'foo1', alias: 'fooa1' }
    const u2 = { name: 'foo2', alias: 'bar' }
    const u3 = { name: 'bar', alias: '3foo' }
    const u4 = { name: 'bar', alias: 'bar' }
    expect(
      fuzzySearch([u1, u2, u3, u4], {
        getText: (item) => [item.name, item.alias],
      })('foo'),
    ).toMatchObject([
      {
        item: u1,
        matches: [[[0, 2]], [[0, 2]]],
      },
      { item: u2, matches: [[[0, 2]], null] },
      { item: u3, matches: [null, [[1, 3]]] },
    ])
  })
  it(`sorts searches by score`, () => {
    expect(
      fuzzySearch([
        '[Marketing] ≈ªabka etc.',
        'Zabawny Katar',
        '≈ªal Betoniarka',
        'ZƒÖbka',
        '≈ªabka',
        '≈ªabowe Karabiny',
        '≈ªabka - oferta wsp√≥≈Çpracy',
        '≈ºabka',
        '[Marketing] ≈ºabka',
      ])('≈ºabka'),
    ).toMatchObject([
      { item: '≈ºabka' /* score: 0 */ },
      { item: 'ZƒÖbka' /* score: 0.1 */ },
      { item: '≈ªabka' /* score: 0.1 */ },
      { item: '≈ªabka - oferta wsp√≥≈Çpracy' /* score: 0.5 */ },
      { item: '[Marketing] ≈ºabka' /* score: 0.9 */ },
      { item: '[Marketing] ≈ªabka etc.' /* score: 1 */ },
      { item: 'Zabawny Katar' /* score: 2 */ },
      { item: '≈ªabowe Karabiny' /* score: 2 */ },
      { item: '≈ªal Betoniarka' /* score: 3 */ },
    ])
  })
  it(`sorts searches by score for many keys`, () => {
    expect(
      fuzzySearch(
        [
          { name: 'Matt', alias: 'Matthias Obst-M√∂linger' },
          { name: 'Marco Couto', alias: null },
          { name: 'Tomasz Kapelak', alias: 'Tom' },
          { name: 'tommy' },
          { name: 'Jacob Tom Belinger', alias: 'Jake' },
        ],
        {
          getText: (item) => [item.name, item.alias],
        },
      )('tom'),
    ).toMatchObject([
      { item: { name: 'Tomasz Kapelak', alias: 'Tom' } /* score: 0.1 */ },
      { item: { name: 'tommy' } /* score: 0.5 */ },
      { item: { name: 'Jacob Tom Belinger', alias: 'Jake' } /* score: 1 */ },
      { item: { name: 'Matt', alias: 'Matthias Obst-M√∂linger' } /* score: 3 */ },
    ])
  })
  it(`returns empty array for empty query`, () => {
    expect(fuzzySearch(['a', 'b', 'c', 'd'])('')).toEqual([])
  })
  const matchesNew = (text, query, ...expectedIndices) => {
    const result = experimentalSmartFuzzyMatch(normalizeText(text), normalizeText(query))
    expect(result).not.toBe(null)
    if (expectedIndices.length) {
      const [, indices] = result
      expect(indices).toEqual(expectedIndices)
    }
  }
  it(`experimentalSmartFuzzyMatch`, () => {
    matchesNew('Wypad do ≈ªabki', 'wd≈º', [0, 0], [6, 6], [9, 9])
    matchesNew('Wypad do ≈ªabki', 'wdz', [0, 0], [6, 6], [9, 9])
    matchesNew('Wypad do ≈ªabki', 'wypa≈ºab', [0, 3], [9, 11])
    matchesNew('Wypad do ≈ªabki', 'wypa ≈ºab', [0, 3], [8, 11])
    matchesNew(
      'Marco Couto',
      'mc',
      [0, 0],
      [3, 3], // NOTE: Ideally would be (6,6), but remaining query is len 1, so [3] matches
    )
    matchesNew('Marco Couto', 'm c', [0, 0], [5, 6])
    matchesNew('Tomasz Kapelak', 'tokp', [0, 1], [7, 7], [9, 9])
    matchesNew('[Marketing ] Referral Program', 'mrefp', [1, 1], [13, 15], [22, 22])
    matchesNew('[Marketing ] Referral Program', 'm refp', [1, 1], [12, 15], [22, 22])
    matchesNew('Nozbe.com web site', 'website', [10, 12], [14, 17])
    matchesNew('KsiƒÖ≈ºka 10 steps EN', '10en')
    // FIXME:
    // matchesNew('Won‚Äôt fix', 'wontfix')
    // matchesNew('[HR] JavaScript Developer', 'jsdev')
    matchesNew('MacKay', 'mckay')
    matchesNew('–†—É—Å—Å–∫–∏–π –Ø–∑—ã–∫', '—É—Å—Å')
    matchesNew('–†—É—Å—Å–∫–∏–π –Ø–∑—ã–∫', '—Ä—É—è')
    matchesNew('Ê±âËØ≠ÁöÑÔºåÂèàÁß∞Ê±âÊñá„ÄÅËèØÊñá„ÄÅÂîêÊñá', 'Ê±âËØ≠Âîê')
    matchesNew('Êó•Êú¨Ë™û', 'Êó•Ë™û')
    matchesNew('ÌïúÍµ≠Ïñ¥', 'ÌïúÏñ¥')

    // new cases
    matchesNew('GH - Growth Hacking', 'growha', [0, 0], [6, 8], [12, 13])
  })
})
